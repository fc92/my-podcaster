#!/usr/bin/env python
# -*- coding: utf-8 -*-

# main program of the podcaster
# TO DO: proper Py doc and unit tests

from pathlib import Path
import os
from mplayer import Player
import subprocess
import time


'''webradios list'''
# podcasts playlist should be generated by gpodder in $HOME/gPodder/Playlists
playlist_dir = str(Path.home())+'/gPodder/Playlists'
# remove former reordered playlists
os.system('find ~/gPodder/Playlists/ -name "*.reordered" -exec rm {} \\;')
podcast_playlists = os.listdir(playlist_dir)
podcast_it = iter(podcast_playlists)

# webradio list is static in this version
radios_url = ['http://direct.franceinfo.fr/live/franceinfo-midfi.mp3',
              "http://live02.rfi.fr/rfimonde-96k.mp3",
              "http://direct.fipradio.fr/live/fip-midfi.mp3",
              "http://ais-live.cloud-services.paris:8000/europe1.mp3",
              "http://bfmbusiness.cdn.dvmr.fr/bfmbusiness",
              "http://windu.radionotredame.net/RadioNotreDame-Fm.mp3"
              ]
radios_it = iter(radios_url)

''' access to mplayer '''
out = open(str(Path.home())+"/mplayer.log", "a")
err = open(str(Path.home())+"/mplayer.err.log", "a")
p = Player(stdout=out, stderr=err)

# Check availability of touch pHat
has_pHat = True
try:
    import touchphat
except ImportError:
    print("touch pHat not available, keyboard interface only (requires X session)")
    has_pHat = False

# import for keyboard if available (usually through ssh -X or for dev)
has_keyboard = True
try:
    from pynput import keyboard
except ImportError:
    import signal
    has_keyboard = False
    print("Keyboard not available")

''' access bluetooth device name for volume control'''
volume = 100
bt_name = ""
bt_address = ""
has_bt = False
# check availability of BT
powered = subprocess.Popen("bluetoothctl show | awk  -F \": \" '/Powered/ {print $2}'",
                           shell=True, stdout=subprocess.PIPE).communicate()[0].decode('ascii').rstrip()
if powered == "yes":
    has_pHat = True
    # get BT information if available
    bt_name = subprocess.Popen("bluetoothctl info | awk  -F \": \" '/Name/ {print $2}'",
                               shell=True, stdout=subprocess.PIPE).communicate()[0].decode('ascii').rstrip()
    print("BT device name = "+bt_name)
    bt_name = subprocess.Popen("bluetoothctl info | awk '/Device/ {print $2}'",
                               shell=True, stdout=subprocess.PIPE).communicate()[0].decode('ascii').rstrip()

else:
    print("BT device not available !!! (this is ok for most developer tasks)")


print("""

Touch pHAT: Buttons Demo & mplayer bluetooth
rely on linux mplayer -> alsa -> bluealsa a2dp source -> bluetooth for audio
rely on gPodder for podcast management
intially designed for Raspberry Pi Zero W 1.1 + Raspbian Buster Lite

Lights up each LED in turn, then detects your button presses.

Press Ctrl+C to exit!

""")

if has_pHat == True:
    for pad in ['Back', 'A', 'B', 'C', 'D', 'Enter']:
        touchphat.set_led(pad, True)
        time.sleep(0.1)
        touchphat.set_led(pad, False)
        time.sleep(0.1)


def next_radio_url():
    """return the URL of next webradio"""
    global radios_it
    try:
        radio = next(radios_it)
        print(radio)
        return radio
    except StopIteration:
        """loop on radio list"""
        radios_it = iter(radios_url)
        return next_radio_url()


def next_podcast():
    """return the path to next podcast playlist file reordered to play newest episod first"""
    global podcast_it, playlist_dir, podcast_playlists
    try:
        nextpodcast = next(podcast_it)
        # lit("lecture du podcast "+nextpodcast)
        podcast = playlist_dir+'/'+nextpodcast
        playlist_reorded = podcast+".reordered"
        # prepare a file with reverse order to play newest epidodes first
        os.system("tac \""+podcast+"\" > \""+playlist_reorded+"\"")
        print(playlist_reorded)
        return playlist_reorded
    except StopIteration:
        """refresh podcast list when the end of the list is reached"""
        podcast_playlists = os.listdir(playlist_dir)
        podcast_it = iter(podcast_playlists)
        return next_podcast()


def volume_apply():
    """ apply new volume value to bluetooth speaker via bluealsa """
    global has_bt, bt_name, volume
    if not has_bt:
        return
    cmd = "amixer -D bluealsa sset '"+bt_name+" - A2DP' "+str(volume)+'%'
    subprocess.check_output(cmd, shell=True)


def volume_up():
    """increase the volume by 10% if possible"""
    global volume
    if (volume < 91):
        volume += 10
        print("volume up 10 %")
        volume_apply()


def volume_down():
    """decrease the volume by 10% if possible"""
    global volume
    if (volume > 9):
        volume -= 10
        print("volume down 10 %")
        volume_apply()


def next_episode_in_podcast():
    '''Play the next episode in the podcast playlist if any'''
    print("next episode in the current podcast playlist")
    p.pt_step(1)


def play_pause():
    '''call mplayer play/pause'''
    print("play/pause")
    p.pause()


def next_podcast_playlist():
    '''Play first episode of the next podcast'''
    print("next podcast playlist")
    p.loadlist(next_podcast())


def next_radio():
    '''play next radio from the radio url list'''
    print("next webradio")
    p.loadfile(next_radio_url())


def map_key_to_podcaster_action(char):
    '''call podcaster action based on the key event received from keyboard or touch pHat'''
    if char.lower() == 'a':
        next_radio()
    elif char.lower() == 'b':
        next_podcast_playlist()
    elif char.lower() == 'c':
        volume_down()
    elif char.lower() == 'd':
        volume_up()
    elif char == '0':
        play_pause()
    elif char == '1':
        next_episode_in_podcast()


# manages touch pHat events if the device is available
if has_pHat == True:
    @touchphat.on_touch(['A', 'B', 'C', 'D', 'Enter', 'Back'])
    def handle_webradio(event):
        '''touch pHat interface
        Back: play/payse
        A: play next radio
        B: play next podcast
        C: volume down
        D: volume up
        Enter: next episode in the current podcast playlist
        '''
        print('Touch pHat {0} pressed'.format(event.name))
        map_key_to_podcaster_action(event.name)

# wait for keyboard event if keyboard is available
if has_keyboard:
    def on_press(key):
        """keyboard interface
        0: play/payse
        a: play next radio
        b: play next podcast
        c: volume down
        d: volume up
        1: next episode in the current podcast playlist
        Esc: exit
        """
        if key == keyboard.Key.esc:
            print("Exiting...")
            exit(0)
        try:
            print('alphanumeric key {0} pressed'.format(key.char))
            map_key_to_podcaster_action(key.char)
        except AttributeError:
            print('special key {0} pressed'.format(key))

    # Collect events until released
    with keyboard.Listener(
            on_press=on_press) as listener:
        listener.join()

# wait for other events (touch pHat)
else:
    signal.pause()
