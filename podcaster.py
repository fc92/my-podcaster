#!/usr/bin/env python
# -*- coding: utf-8 -*-

# main program of the podcaster
# TO DO: proper Py doc and unit tests

from pathlib import Path
import os
from mplayer import Player
import subprocess
import time

from pynput import keyboard


'''webradios list'''
# podcasts playlist should be generated by gpodder in $HOME/gPodder/Playlists
playlist_dir = str(Path.home())+'/gPodder/Playlists'
podcast_playlists = os.listdir(playlist_dir)
podcast_it = iter(podcast_playlists)

# webradio list is static in this version
radios_url = ['http://direct.franceinfo.fr/live/franceinfo-midfi.mp3',
              "http://live02.rfi.fr/rfimonde-96k.mp3",
              "http://direct.fipradio.fr/live/fip-midfi.mp3",
              "http://ais-live.cloud-services.paris:8000/europe1.mp3",
              "http://bfmbusiness.cdn.dvmr.fr/bfmbusiness",
              "http://windu.radionotredame.net/RadioNotreDame-Fm.mp3"
              ]
radios_it = iter(radios_url)

''' access to mplayer '''
out = open(str(Path.home())+"/podcaster.out", "a")
err = open(str(Path.home())+"/podcaster.err", "a")
p = Player(stdout=out, stderr=err)

# Check availability of touch pHat
has_pHat = True
try:
    import touchphat
except ImportError:
    print("touch pHat not available, keyboard interface only")
    has_pHat = False

''' access bluetooth device name for volume control'''
volume = 100
bt_name = ""
bt_address = ""
has_bt = False
# check availability of BT
powered = subprocess.Popen("bluetoothctl show | awk  -F \": \" '/Powered/ {print $2}'",
                           shell=True, stdout=subprocess.PIPE).communicate()[0].decode('ascii').rstrip()
if powered == "yes":
    has_pHat = True
    # get BT information if available
    bt_name = subprocess.Popen("bluetoothctl info | awk  -F \": \" '/Name/ {print $2}'",
                               shell=True, stdout=subprocess.PIPE).communicate()[0].decode('ascii').rstrip()
    print("BT device name = "+bt_name)
    bt_name = subprocess.Popen("bluetoothctl info | awk '/Device/ {print $2}'",
                               shell=True, stdout=subprocess.PIPE).communicate()[0].decode('ascii').rstrip()

else:
    print("BT device not available !!! (this is ok for most developer tasks)")


print("""

Touch pHAT: Buttons Demo & mplayer bluetooth
rely on linux mplayer -> alsa -> bluealsa a2dp source -> bluetooth for audio
rely on gPodder for podcast management
intially designed for Raspberry Pi Zero W 1.1 + Raspbian Buster Lite

Lights up each LED in turn, then detects your button presses.

Press Ctrl+C to exit!

""")

if has_pHat == True:
    for pad in ['Back', 'A', 'B', 'C', 'D', 'Enter']:
        touchphat.set_led(pad, True)
        time.sleep(0.1)
        touchphat.set_led(pad, False)
        time.sleep(0.1)


def lit(txt):
    """lit le texte"""
    cmd = 'espeak -v fr+m1 "'+txt+'" --stdout | aplay'
    os.system(cmd)


def next_radio():
    """return the URL of next webradio"""
    global radios_it
    try:
        radio = next(radios_it)
        print(radio)
        return radio
    except StopIteration:
        """loop on radio list"""
        radios_it = iter(radios_url)
        return next_radio()


def next_podcast():
    """return the path to next podcast playlist file reordered to play newest episod first"""
    global podcast_it, playlist_dir, podcast_playlists
    try:
        nextpodcast = next(podcast_it)
        # lit("lecture du podcast "+nextpodcast)
        podcast = playlist_dir+'/'+nextpodcast
        playlist_reorded = podcast+".reordered"
        # prepare a file with reverse order to play newest epidodes first
        os.system("tac \""+podcast+"\" > \""+playlist_reorded+"\"")
        print(playlist_reorded)
        return playlist_reorded
    except StopIteration:
        """refresh podcast list when the end of the list is reached"""
        podcast_playlists = os.listdir(playlist_dir)
        podcast_it = iter(podcast_playlists)
        return next_podcast()


def volume_apply():
    """ apply new volume value to bluetooth speaker via bluealsa """
    global has_bt, bt_name, volume
    if not has_bt:
        return
    cmd = "amixer -D bluealsa sset '"+bt_name+" - A2DP' "+str(volume)+'%'
    print(cmd)
#		cmd += ' 2>&1 >/dev/null'
    subprocess.check_output(cmd, shell=True)


def volume_up():
    """increase the volume by 10% if possible"""
    global volume
    if (volume < 91):
        volume += 10
        volume_apply()


def volume_down():
    """decrease the volume by 10% if possible"""
    global volume
    if (volume > 9):
        volume -= 10
        volume_apply()


if has_pHat == True:
    @touchphat.on_touch(['A', 'B'])
    def handle_webradio(event):
        """ when button A is pressed play next webradio
        when button B is pressed play next playing list (generated by gPodder for podcasts)"""
        global p
        if event.name == 'A':
            p.loadfile(next_radio())
        elif event.name == 'B':
            p.loadlist(next_podcast())
        print(p.filename)

    @touchphat.on_touch(['C', 'D'])
    def handle_volume(event):
        """ manage volume decrease and increase commands from buttons C and D"""
        if event.name == 'C':
            volume_down()
        elif event.name == 'D':
            volume_up()

    @touchphat.on_touch(['Back'])
    def handle_pause(event):
        """button Back allows to pause/resume current audio stream"""
        global p
        print("play/pause")
        p.pause()

    @touchphat.on_touch(['Enter'])
    def handle_enter(event):
        """button Enter allows to step to next episode in a podcast"""
        print("next episode")
        p.step()


def on_press(key):
    """keyboard interface
    0: play/payse
    a: play next radio
    b: play next podcast
    c: volume down
    d: volume up
    1: TBD next episode
    Esc: exit
    """
    global p
    if key == keyboard.Key.esc:
        print("Exiting...")
        exit(0)
    try:
        print('alphanumeric key {0} pressed'.format(key.char))
        if key.char == 'a':
            p.loadfile(next_radio())
        elif key.char == 'b':
            p.loadlist(next_podcast())
        elif key.char == 'c':
            volume_down()
        elif key.char == 'd':
            volume_up()
        elif key.char == '0':
            print("play/pause")
            p.pause()
        elif key.char == '1':
            print("next episode")
            p.step()
    except AttributeError:
        print('special key {0} pressed'.format(key))


# Collect events until released
with keyboard.Listener(
        on_press=on_press) as listener:
    listener.join()
